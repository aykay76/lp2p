<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local P2P Messenger</title>
    <link rel="stylesheet" href="main.css">
    <style>

    </style>
</head>
<body>
    <div class="app-shell">
        <header class="app-header">
            <div class="app-title">üîó Local P2P Messenger</div>
            <div class="app-subtitle">WebRTC peer-to-peer</div>
            <div id="identityInfo" class="identity-badge">Initializing...</div>
        </header>

        <div class="status-bar">
            <div class="status-indicator" id="statusIndicator"></div>
            <div class="status-text" id="statusText">Disconnected</div>
        </div>

        <!-- Username Setup Modal (shown on first load) -->
        <div id="usernameModal" class="username-modal">
            <div class="modal-card">
                <h2 class="modal-title">üëã Welcome to LP2P!</h2>
                <p class="modal-desc">Choose a display name for your identity. This will be shown to peers you connect with.</p>
                <input type="text" id="usernameInput" placeholder="Enter your name..." class="input-full" />
                <button onclick="setUsername()" class="btn-block btn-primary">Continue</button>
            </div>
        </div>

        <!-- Fingerprint Verification Modal -->
        <div id="fingerprintModal" class="modal-overlay">
            <div class="modal-card large">
                <div class="center">
                    <div class="icon-large">üîê</div>
                    <h2 class="fingerprint-title">Fingerprint Verification</h2>
                    <p class="fingerprint-paragraph">Compare fingerprints to verify identity</p>
                </div>

                <!-- Your Fingerprint -->
                <div class="fingerprint-card fingerprint-your">
                    <div class="fingerprint-title-strong">
                        ‚úì Your Fingerprint
                    </div>
                    <div id="myFingerprintDisplay" class="fingerprint-mono"></div>
                </div>

                <!-- Peer's Fingerprint -->
                <div class="fingerprint-card fingerprint-peer">
                    <div class="fingerprint-title-strong">
                        ‚ö†Ô∏è <span id="peerNameDisplay"></span>'s Fingerprint
                    </div>
                    <div id="peerFingerprintDisplay" class="fingerprint-mono"></div>
                </div>

                <!-- Verification Instructions -->
                <div class="verification-steps">
                    <div class="verification-header">üìã Verification Steps:</div>
                    <ol class="verification-ol">
                        <li>Contact <strong id="peerNameDisplay2"></strong> through a trusted channel (phone, video, in person)</li>
                        <li>Ask them to read their fingerprint aloud</li>
                        <li>Compare it character-by-character with the orange fingerprint above</li>
                        <li>If they match exactly, set trust to "Full Trust"</li>
                        <li>If they don't match, set trust to "Untrusted" immediately</li>
                    </ol>
                </div>

                <!-- Trust Level Selector -->
                <div class="trust-card">
                    <label class="label-block">
                        Set Trust Level:
                    </label>
                    <select id="trustLevelModal" class="select-full">
                        <option value="unknown">‚ùì Unknown - Not yet verified</option>
                        <option value="untrusted">‚õî Untrusted - Do NOT trust</option>
                        <option value="marginal">‚ö†Ô∏è Marginal Trust - Partially verified</option>
                        <option value="full">‚úÖ Full Trust - Fingerprint verified</option>
                    </select>
                </div>

                <!-- Action Buttons -->
                <div class="flex-row">
                    <button onclick="closeFingerprintModal()" class="flex-1 btn-block btn-secondary">Cancel</button>
                    <button onclick="saveTrustLevel()" class="flex-1 btn-block btn-primary">Save Trust Level</button>
                </div>
            </div>
        </div>

        <div class="app-body">
            <aside id="sidebar" class="sidebar">
                <div class="sidebar-section contacts-section" id="contactsSection">
                    <h3>üë• Contacts</h3>
                    <div id="peerRosterList" class="section-content">
                        <div class="no-peers">No peers</div>
                    </div>
                    <div class="sidebar-actions">
                        <button class="btn-primary btn-small" onclick="promptAddContact()">‚ûï Add Contact</button>
                    </div>
                    <div class="sidebar-actions" style="margin-top:6px;">
                        <button class="btn-secondary btn-small" onclick="refreshPresence()" title="Ping all contacts to check who's online">üîÑ Check Who's Online</button>
                    </div>
                </div>

                <div class="sidebar-resizer" id="sidebarResizer"></div>

                <div class="sidebar-section rooms-section" id="roomsSection">
                    <h3>üìÅ Rooms</h3>
                    <div id="channelsList" class="section-content">
                        <div class="no-rooms">No channels yet</div>
                    </div>
                    <div class="sidebar-actions">
                        <button class="btn-primary btn-small" onclick="createRoomDialog()">‚ûï New Room</button>
                    </div>
                </div>
            </aside>

            <main class="main-area">
                <section id="roomView" class="panel panel-hero">
                    <h2 id="roomTitle">üöÄ Quick Connect</h2>
                    <div class="flex-row mb-16">
                        <button class="btn-primary flex-1" onclick="createRoom()">üè† Create Room</button>
                        <button class="btn-primary flex-1" onclick="showJoinRoomDialog()">üîó Join Room</button>
                    </div>

                    <div id="roomDisplay" class="room-display">
                        <div class="small-muted">Room Code</div>
                        <div id="roomCodeDisplay" class="room-code">------</div>
                        <div class="small-muted">Share this code with others to let them join</div>
                        <div id="qrCodeContainer" class="qr-container">
                            <img id="qrCodeImage" class="qr-image">
                        </div>
                        <button onclick="copyRoomCode()" class="btn-success mr-8">üìã Copy Code</button>
                        <button onclick="showQRCode()" class="btn-primary">üì± Show QR</button>
                    </div>

                    <div class="muted-box">
                        <strong>üí° Tip:</strong> Room-based connection uses localStorage. Works great for same-device testing or devices on the same network with shared storage.
                    </div>
                </section>

                <section class="panel chat-panel">
                    <div class="chat-header">
                        <div class="chat-title">üí¨ Messages</div>
                        <div id="peerInfoPanel" class="peer-info-panel">
                            <div class="peer-info-top">
                                <div class="flex-1">
                                    <strong>Selected Peer</strong><br>
                                    <div id="peerName" class="peer-name-style"></div>
                                    <div class="small-code">Key ID: <code id="peerKeyId"></code><br>Fingerprint: <code id="peerFingerprint" class="small-code"></code></div>
                                </div>
                                <div class="text-right">
                                    <div class="mb-8"><strong class="trust-strong">Trust Level:</strong><br>
                                        <select id="trustLevelSelect" onchange="updateTrustLevel()" class="trust-select">
                                            <option value="unknown">‚ùì Unknown</option>
                                            <option value="untrusted">‚õî Untrusted</option>
                                            <option value="marginal">‚ö†Ô∏è Marginal</option>
                                            <option value="full">‚úÖ Full Trust</option>
                                        </select>
                                    </div>
                                    <button onclick="showFingerprintComparison()" class="verify-btn">üîç Verify Fingerprint</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="messages" id="messages"><div class="center-muted">No connection yet. Complete the signaling process to start chatting.</div></div>

                    <div class="message-input-group"><input type="text" id="messageInput" placeholder="Type your message..." disabled><button class="btn-primary" id="sendBtn" onclick="sendMessage()" disabled>Send</button></div>
                </section>

                <!-- Manual signaling section (collapsible) -->
                <details class="panel" style="margin-top: 16px;">
                    <summary class="summary-btn">üîß Manual Signaling (Advanced)</summary>
                    <div style="margin-top: 12px;">
                        <h3 class="h3-style">üë§ Peer A (Offerer)</h3>
                        <div class="instructions">
                            <strong>Step 1:</strong> Create an offer
                        </div>
                        <button class="btn-primary" id="createOfferBtn" onclick="createOffer()">Create Offer</button>
                        <textarea id="offerText" class="signal-area" placeholder="Your offer will appear here..." readonly></textarea>
                        
                        <div class="help-text">üìã Copy this offer and paste it in Peer B on the other browser</div>

                        <h3 class="h3-style h3-spaced">üì• Paste Answer Here</h3>
                        
                        <textarea id="answerInput" class="signal-area" placeholder="Paste the answer from Peer B here..."></textarea>
                        
                        <button class="btn-success" id="setAnswerBtn" onclick="setAnswer()" disabled>Apply Answer</button>

                        <h3 class="h3-style" style="margin-top: 20px;">üë§ Peer B (Answerer)</h3>
                        
                        <div class="instructions">
                            <strong>Step 2:</strong> Paste the offer from Peer A
                        </div>

                        <textarea id="offerInput" class="signal-area" placeholder="Paste the offer from Peer A here..."></textarea>
                        
                        <div class="button-group">
                            <button class="btn-primary" id="createAnswerBtn" onclick="createAnswer()">Create Answer</button>
                        </div>

                        <textarea id="answerText" class="signal-area" placeholder="Your answer will appear here..." readonly></textarea>
                        
                        <div class="help-text">üìã Copy this answer and paste it in Peer A on the other browser</div>

                        <h3 class="h3-style" style="margin-top: 20px;">üß© Additional Offers</h3>
                        <div class="small-muted">Create separate offers for each extra peer you want to join. Each peer creates an answer from its own browser and you apply it here.</div>
                        <div id="multiOffersContainer" class="multi-offers"></div>
                        <button class="btn-secondary mt-8" onclick="createAdditionalOffer()">‚ûï New Offer</button>
                        <div class="help-text">Use a new offer per joining peer. Answers can't be reused.</div>
                    </div>
                </details>
            </main>
        </div>
    </div>

    <!-- User Interface Layer -->
    <script src="ui.js"></script>

    <!-- Protocol Layer -->
    <script src="protocol.js"></script>
    
    <!-- Identity Layer -->
    <script src="identity.js"></script>

    <!-- PeerJS for signaling -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- Signaling Layer -->
    <script src="signaling.js"></script>

    <script>
        // WebRTC Configuration
        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Global state
        let peerConnection = null;
        let dataChannel = null;
        let isOfferer = false;
        let peerId = null;  // Our peer ID
        let remotePeerId = null;  // Remote peer ID
        let messageHandler = null;  // Message handler instance
        let identityManager = null;  // Identity manager instance
        let ownIdentity = null;  // Our identity
    // Multi-party additions
    const connections = new Map(); // connectionId -> { pc, dc, peerId, state }
    let activePeerId = null; // Currently focused peer for UI/trust panel

    // Room-based signaling
        let roomSignaling = null;
        let currentRoomCode = null;
        let isRoomHost = false;

    // Helper: get connection entry by peerId
    function getConnectionByPeerId(pid) {
        for (const [cid, conn] of connections.entries()) {
            if (conn.peerId === pid) return conn;
        }
        return null;
    }

    // Helper: relay a message from one peer to all others (host only)
    function relayToOthers(message, rawWire) {
        if (connections.size < 2) return; // Nothing to relay
        for (const [cid, conn] of connections.entries()) {
            if (!conn.dc || conn.dc.readyState !== 'open') continue;
            if (conn.peerId === message.from) continue; // Skip sender
            try {
                conn.dc.send(rawWire);
            } catch (e) {
                console.warn('Relay send failed for connection', cid, e);
            }
        }
    }

    // Build peerInfo from trust record
    function buildPeerInfo(record) {
        return {
            id: record.peerId,
            keyId: record.keyId,
            fingerprint: record.fingerprint,
            publicKey: record.publicKey,
            profile: record.profile
        };
    }

        // Utility: wait for ICE on a specific PeerConnection
        function waitForICEOn(pc) {
            return new Promise((resolve) => {
                if (pc.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    pc.addEventListener('icegatheringstatechange', () => {
                        if (pc.iceGatheringState === 'complete') {
                            resolve();
                        }
                    });
                }
            });
        }

        // Create additional offer (host side multi-party)
        async function createAdditionalOffer() {
            try {
                const connectionId = crypto.randomUUID();
                const pc = new RTCPeerConnection(config);
                const dc = pc.createDataChannel('messages');

                connections.set(connectionId, { pc, dc, peerId: null, state: 'offer-created' });
                console.log('Creating additional offer, connection:', connectionId);

                // Wire handlers (minimal duplication from setupDataChannel but isolated per connection)
                dc.onopen = () => {
                    console.log('Data channel opened (multi)', connectionId);
                    const entry = connections.get(connectionId);
                    if (entry) entry.state = 'open';
                    sendHello(dc); // introduce via this channel only
                    enableChat();
                };
                dc.onclose = () => {
                    console.log('Data channel closed (multi)', connectionId);
                    const entry = connections.get(connectionId);
                    if (entry) entry.state = 'closed';
                    disableChat();
                };
                dc.onmessage = async (event) => {
                    console.log('Multi channel message raw:', event.data);
                    try {
                        const message = LP2P.Message.deserialize(event.data);
                        if (message.signature) {
                            const isValid = await verifyMessage(message);
                            message.signatureValid = isValid;
                        }
                        await messageHandler.handle(message);
                        // Relay (host) incoming text to other peers
                        if (connections.size > 1 && message.type === LP2P.MESSAGE_TYPES.TEXT && message.from !== peerId) {
                            relayToOthers(message, event.data);
                        }
                        if (message.from) {
                            activePeerId = message.from;
                        }
                    } catch (err) {
                        console.error('Error in multi channel message:', err);
                    }
                };

                pc.onconnectionstatechange = () => {
                    console.log('Multi PC state', connectionId, pc.connectionState);
                    if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                        const entry = connections.get(connectionId);
                        if (entry) entry.state = pc.connectionState;
                    }
                };

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await waitForICEOn(pc);

                // Render offer block UI
                const container = document.getElementById('multiOffersContainer');
                const blockId = 'offer_block_' + connectionId;
                const answerInputId = 'answer_input_' + connectionId;
                const applyBtnId = 'apply_btn_' + connectionId;
                const offerStr = JSON.stringify(pc.localDescription);
                const div = document.createElement('div');
                div.id = blockId;
                div.style.border = '1px solid #ccc';
                div.style.padding = '10px';
                div.style.borderRadius = '6px';
                div.style.background = '#f9fafb';
                div.innerHTML = `
                    <div style=\"display:flex; justify-content:space-between; align-items:center;\">
                        <strong style=\"font-size:13px;\">Offer for Peer (ID: ${connectionId.substring(0,8)})</strong>
                        <span style=\"font-size:10px; color:#666;\" id=\"state_${connectionId}\">waiting-answer</span>
                    </div>
                    <textarea readonly style=\"width:100%; height:90px; font-size:11px; margin-top:6px;\">${offerStr}</textarea>
                    <div style=\"font-size:11px; color:#555; margin:4px 0;\">Peer should paste this offer in their browser and generate an answer. Paste their answer below:</div>
                    <textarea id=\"${answerInputId}\" style=\"width:100%; height:90px; font-size:11px;\" placeholder=\"Paste answer here...\"></textarea>
                    <div style=\"display:flex; gap:8px; margin-top:6px;\">
                        <button id=\"${applyBtnId}\" style=\"flex:1; background:#667eea; color:#fff; border:none; padding:6px 10px; border-radius:4px; cursor:pointer; font-size:12px;\" onclick=\"applyAdditionalAnswer('${connectionId}', '${answerInputId}', '${applyBtnId}')\">Apply Answer</button>
                        <button style=\"background:#e53e3e; color:#fff; border:none; padding:6px 10px; border-radius:4px; cursor:pointer; font-size:12px;\" onclick=\"removeOfferBlock('${connectionId}', '${blockId}')\">Remove</button>
                    </div>
                `;
                container.appendChild(div);
            } catch (error) {
                console.error('Error creating additional offer:', error);
                alert('Failed to create additional offer: ' + error.message);
            }
        }

        async function applyAdditionalAnswer(connectionId, answerInputId, applyBtnId) {
            try {
                const entry = connections.get(connectionId);
                if (!entry) {
                    alert('Unknown connection');
                    return;
                }
                const answerText = document.getElementById(answerInputId).value.trim();
                if (!answerText) {
                    alert('Paste an answer first');
                    return;
                }
                const answer = JSON.parse(answerText);
                await entry.pc.setRemoteDescription(new RTCSessionDescription(answer));
                entry.state = 'connected-or-connecting';
                document.getElementById('state_' + connectionId).textContent = 'applied';
                const btn = document.getElementById(applyBtnId);
                if (btn) btn.disabled = true;
                console.log('Applied answer for connection', connectionId);
            } catch (error) {
                console.error('Error applying additional answer:', error);
                alert('Failed to apply answer: ' + error.message);
            }
        }

        /**
         * Initialize RTCPeerConnection
         */
        function initPeerConnection() {
            peerConnection = new RTCPeerConnection(config);

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate === null) {
                    // ICE gathering complete
                    console.log('ICE gathering complete');
                }
            };

            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                
                switch (peerConnection.connectionState) {
                    case 'connecting':
                        updateStatus('connecting', 'Connecting...');
                        break;
                    case 'connected':
                        updateStatus('connected', 'Connected');
                        break;
                    case 'disconnected':
                        updateStatus('', 'Disconnected');
                        disableChat();
                        break;
                    case 'failed':
                        updateStatus('', 'Connection failed');
                        disableChat();
                        break;
                }
            };

            // Handle incoming data channel (for answerer)
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel();
            };
        }

        /**
         * Setup data channel event handlers
         */
        function setupDataChannel() {
            // Register a new connection entry
            const connectionId = crypto.randomUUID();
            connections.set(connectionId, { pc: peerConnection, dc: dataChannel, peerId: null, state: 'pending' });
            console.log('Registered new connection', connectionId);

            dataChannel.onopen = () => {
                console.log('Data channel opened');
                const conn = connections.get(connectionId);
                if (conn) {
                    conn.state = 'open';
                }
                
                // Send hello message to introduce ourselves
                sendHello();
                
                enableChat();
            };

            dataChannel.onclose = () => {
                console.log('Data channel closed');
                const conn = connections.get(connectionId);
                if (conn) {
                    conn.state = 'closed';
                }
                
                // Send goodbye if still connected to peer
                if (remotePeerId) {
                    sendGoodbye();
                }
                
                disableChat();
            };

            dataChannel.onmessage = async (event) => {
                console.log('Received raw data:', event.data);
                
                try {
                    // Deserialize the message
                    const message = LP2P.Message.deserialize(event.data);
                    console.log('Received message:', message);
                    
                    // Verify signature if present
                    if (message.signature) {
                        const isValid = await verifyMessage(message);
                        console.log('Message signature valid:', isValid);
                        message.signatureValid = isValid;
                    }
                    
                    // Handle the message
                    await messageHandler.handle(message);

                    // Relay if host has multiple connections and this is peer-originated text
                    if (connections.size > 1 && message.type === LP2P.MESSAGE_TYPES.TEXT && message.from !== peerId) {
                        relayToOthers(message, event.data);
                    }

                    // Set active peer for UI focus
                    if (message.from) {
                        activePeerId = message.from;
                    }
                } catch (error) {
                    console.error('Error handling message:', error);
                    
                    // Send error response if possible
                    if (remotePeerId) {
                        const errorMsg = LP2P.MessageFactory.createError(
                            peerId,
                            remotePeerId,
                            LP2P.ERROR_CODES.INVALID_FORMAT,
                            error.message
                        );
                        sendRawMessage(errorMsg);
                    }
                }
            };

            dataChannel.onerror = (error) => {
                console.error('Data channel error:', error);
            };
        }

        // ====================================================================
        // Room-Based Signaling Functions
        // ====================================================================

        /**
         * Create a new room and become host
         */
        async function createRoom() {
            try {
                currentRoomCode = LP2PSignaling.PeerJSSignaling.generateRoomCode();
                isRoomHost = true;
                
                console.log('Creating room', currentRoomCode, 'with peerId', peerId);
                
                roomSignaling = new LP2PSignaling.PeerJSSignaling();
                // expose current signaling instance for UI helpers
                window.signaling = roomSignaling;
                await roomSignaling.joinRoom(currentRoomCode, 'host'); // Host always uses 'host' as peerId
                
                // Host receives offers from joining peers
                roomSignaling.onOffer = async (sdp, fromPeerId) => {
                    console.log('HOST: Received offer from', fromPeerId);
                    await handleIncomingOffer(sdp, fromPeerId);
                };
                
                // Host may also receive answers if needed
                roomSignaling.onAnswer = async (sdp, fromPeerId) => {
                    console.log('HOST: Received answer from', fromPeerId);
                    await handleIncomingAnswer(sdp, fromPeerId);
                };
                
                // Display room code
                document.getElementById('roomCodeDisplay').textContent = currentRoomCode;
                document.getElementById('roomDisplay').style.display = 'block';
                
                addSystemMessage(`üè† Room created: ${currentRoomCode}`);
                updateStatus('connecting', `Room ${currentRoomCode} - Waiting for peers`);
            } catch (error) {
                console.error('Error creating room:', error);
                alert('Failed to create room: ' + error.message);
            }
        }


        /**
         * Join an existing room
         */
        async function joinRoom(roomCode) {
            try {
                currentRoomCode = roomCode;
                isRoomHost = false;
                
                console.log('PEER: Joining room', currentRoomCode, 'with peerId', peerId);
                
                roomSignaling = new LP2PSignaling.PeerJSSignaling();
                // expose current signaling instance for UI helpers
                window.signaling = roomSignaling;
                await roomSignaling.joinRoom(currentRoomCode, peerId);
                
                // Client receives offers from host
                roomSignaling.onOffer = async (sdp, fromPeerId) => {
                    console.log('PEER: Received offer from host', fromPeerId);
                    await handleIncomingOffer(sdp, fromPeerId);
                };
                
                // Client receives answers to our offer
                roomSignaling.onAnswer = async (sdp, fromPeerId) => {
                    console.log('PEER: Received answer from', fromPeerId);
                    await handleIncomingAnswer(sdp, fromPeerId);
                };
                
                // Create and post our offer to the room
                console.log('PEER: Creating and posting offer...');
                await createAndPostOffer();
                
                addSystemMessage(`üîó Joined room: ${currentRoomCode}`);
                updateStatus('connecting', `Connecting to room ${currentRoomCode}...`);
            } catch (error) {
                console.error('Error joining room:', error);
                alert('Failed to join room: ' + error.message);
            }
        }

        /**
         * Create offer and post to room
         */
        async function createAndPostOffer() {
            try {
                const connectionId = crypto.randomUUID();
                const pc = new RTCPeerConnection(config);
                const dc = pc.createDataChannel('messages');

                connections.set(connectionId, { pc, dc, peerId: null, state: 'offer-created' });
                
                setupDataChannelForConnection(dc, connectionId);
                setupPeerConnectionForConnection(pc, connectionId);

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await waitForICEOn(pc);

                const offerSDP = JSON.stringify(pc.localDescription);
                        await roomSignaling.postOffer(offerSDP, '*');  // Broadcast to all (host will pick it up)
                
                console.log('Posted offer to room successfully');
            } catch (error) {
                console.error('Failed to create/post offer:', error);
                alert('Could not connect to room. Make sure the host has created the room first!\n\nError: ' + error.message);
            }
        }

                /**
                 * Create a direct offer to a specific peer via global PeerJS signaling
                 */
                async function createDirectOffer(targetPeerId) {
                    if (!window.globalPeerJS || !window.globalPeerJS.peer) {
                        alert('Not connected to P2P network. Please wait for connection or refresh the page.');
                        return;
                    }

                    try {
                        const connectionId = crypto.randomUUID();
                        const pc = new RTCPeerConnection(config);
                        const dc = pc.createDataChannel('messages');

                        connections.set(connectionId, { pc, dc, peerId: null, state: 'offer-created' });

                        setupDataChannelForConnection(dc, connectionId);
                        setupPeerConnectionForConnection(pc, connectionId);

                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        await waitForICEOn(pc);

                        const offerSDP = JSON.stringify(pc.localDescription);
                        // Send via global PeerJS to specific peer
                        await window.globalPeerJS.sendToPeer(`lp2p-${targetPeerId}`, {
                            type: 'offer',
                            from: peerId,
                            sdp: offerSDP
                        });
                        console.log('‚úâÔ∏è Sent direct offer to', targetPeerId);
                        addSystemMessage(`üì§ Connecting to ${targetPeerId.substring(0, 12)}...`);
                    } catch (err) {
                        console.error('Failed to create direct offer', err);
                        alert('Failed to create direct offer: ' + err.message);
                    }
                }

        /**
         * Handle incoming offer (host or peer)
         */
        async function handleIncomingOffer(sdpString, fromPeerId) {
            const connectionId = crypto.randomUUID();
            const pc = new RTCPeerConnection(config);

            connections.set(connectionId, { pc, dc: null, peerId: null, state: 'answering', remotePeerId: fromPeerId });
            
            setupPeerConnectionForConnection(pc, connectionId);

            // Incoming data channel
            pc.ondatachannel = (event) => {
                const dc = event.channel;
                const conn = connections.get(connectionId);
                if (conn) conn.dc = dc;
                setupDataChannelForConnection(dc, connectionId);
            };

            const offer = JSON.parse(sdpString);
            await pc.setRemoteDescription(new RTCSessionDescription(offer));

            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await waitForICEOn(pc);

            const answerSDP = JSON.stringify(pc.localDescription);
            roomSignaling.postAnswer(answerSDP, fromPeerId);
            
            console.log('Posted answer to room');
        }

        /**
         * Handle incoming answer
         */
        async function handleIncomingAnswer(sdpString, fromPeerId) {
            console.log('üîç Looking for connection to apply answer from', fromPeerId);
            console.log('Available connections:', Array.from(connections.entries()).map(([id, c]) => ({
                id: id.substring(0, 8),
                state: c.state,
                hasRemote: !!c.pc.remoteDescription,
                signalingState: c.pc.signalingState
            })));
            
            // Find connection awaiting answer (check for offer-created OR connecting without remote description)
            for (const [cid, conn] of connections.entries()) {
                if ((conn.state === 'offer-created' || conn.state === 'connecting') && !conn.pc.remoteDescription) {
                    console.log('‚úÖ Applying answer to connection', cid.substring(0, 8));
                    const answer = JSON.parse(sdpString);
                    await conn.pc.setRemoteDescription(new RTCSessionDescription(answer));
                    console.log('‚úÖ Answer applied successfully, ICE state:', conn.pc.iceConnectionState);
                    return;
                }
            }
            console.error('‚ùå No connection found to apply answer!');
        }

        /**
         * Setup data channel for a specific connection
         */
        function setupDataChannelForConnection(dc, connectionId) {
            dc.onopen = () => {
                console.log('Data channel opened (room)', connectionId);
                const entry = connections.get(connectionId);
                if (entry) entry.state = 'open';
                sendHello(dc);
                enableChat();
            };
            
            dc.onclose = () => {
                console.log('Data channel closed (room)', connectionId);
                const entry = connections.get(connectionId);
                if (entry) entry.state = 'closed';
            };
            
            dc.onmessage = async (event) => {
                try {
                    const message = LP2P.Message.deserialize(event.data);
                    if (message.signature) {
                        const isValid = await verifyMessage(message);
                        message.signatureValid = isValid;
                    }
                    await messageHandler.handle(message);
                    
                    // Relay for host
                    if (isRoomHost && connections.size > 1 && message.type === LP2P.MESSAGE_TYPES.TEXT && message.from !== peerId) {
                        relayToOthers(message, event.data);
                    }
                    
                    if (message.from) {
                        activePeerId = message.from;
                    }
                } catch (err) {
                    console.error('Error in room channel message:', err);
                }
            };
        }

        /**
         * Setup peer connection for a specific connection
         */
        function setupPeerConnectionForConnection(pc, connectionId) {
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('ICE candidate:', event.candidate.type, event.candidate.protocol);
                } else {
                    console.log('ICE gathering complete');
                }
            };
            
            pc.onicegatheringstatechange = () => {
                console.log('ICE gathering state:', pc.iceGatheringState);
            };
            
            pc.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', pc.iceConnectionState);
            };
            
            pc.onconnectionstatechange = () => {
                console.log('Room PC state', connectionId, pc.connectionState);
                const entry = connections.get(connectionId);
                if (entry) {
                    entry.state = pc.connectionState;
                    if (pc.connectionState === 'connected') {
                        updateStatus('connected', `Connected to room ${currentRoomCode}`);
                    } else if (pc.connectionState === 'failed') {
                        console.error('WebRTC connection failed!');
                        updateStatus('error', 'Connection failed');
                    }
                }
            };
        }

        // ====================================================================
        // Manual Signaling Functions (Original)
        // ====================================================================

        /**
         * Create an offer (Peer A)
         */
        async function createOffer() {
            try {
                isOfferer = true;
                initPeerConnection();

                // Create data channel
                dataChannel = peerConnection.createDataChannel('messages');
                setupDataChannel();

                // Create and set local description
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Wait for ICE gathering to complete
                await waitForICE();

                // Display offer
                offerText.value = JSON.stringify(peerConnection.localDescription);
                
                // Enable answer input
                setAnswerBtn.disabled = false;
                
                updateStatus('connecting', 'Offer created - waiting for answer');
                
                console.log('Offer created:', peerConnection.localDescription);
            } catch (error) {
                console.error('Error creating offer:', error);
                alert('Failed to create offer: ' + error.message);
            }
        }

        /**
         * Create an answer (Peer B)
         */
        async function createAnswer() {
            try {
                const offerText = offerInput.value.trim();
                
                if (!offerText) {
                    alert('Please paste an offer first');
                    return;
                }

                isOfferer = false;
                initPeerConnection();

                // Parse and set remote description
                const offer = JSON.parse(offerText);
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                // Create and set local description
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                // Wait for ICE gathering to complete
                await waitForICE();

                // Display answer
                answerText.value = JSON.stringify(peerConnection.localDescription);
                
                updateStatus('connecting', 'Answer created - waiting for connection');
                
                console.log('Answer created:', peerConnection.localDescription);
            } catch (error) {
                console.error('Error creating answer:', error);
                alert('Failed to create answer: ' + error.message);
            }
        }

        /**
         * Set answer (Peer A)
         */
        async function setAnswer() {
            try {
                const answerStr = answerInput.value.trim();
                
                if (!answerStr) {
                    alert('Please paste an answer first');
                    return;
                }

                const answer = JSON.parse(answerStr);
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                
                console.log('Answer applied');
                setAnswerBtn.disabled = true;
            } catch (error) {
                console.error('Error setting answer:', error);
                alert('Failed to apply answer: ' + error.message);
            }
        }

        /**
         * Wait for ICE gathering to complete
         */
        function waitForICE() {
            return new Promise((resolve) => {
                if (peerConnection.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    peerConnection.addEventListener('icegatheringstatechange', () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            resolve();
                        }
                    });
                }
            });
        }

        /**
         * Send a message
         */
        async function sendMessage() {
            const text = messageInput.value.trim();
            
            if (!text) return;
            
            try {
                // Multi-party broadcast if we have any registered connections
                if (connections.size > 0) {
                    let sentCount = 0;
                    let unidentifiedConnections = 0;
                    for (const [cid, conn] of connections.entries()) {
                        if (!conn.dc || conn.dc.readyState !== 'open') continue;
                        if (!conn.peerId) { unidentifiedConnections++; continue; } // wait for HELLO mapping
                        const msg = LP2P.MessageFactory.createText(peerId, conn.peerId, text);
                        await signMessage(msg);
                        const validation = LP2P.MessageValidator.validate(msg);
                        if (!validation.valid) {
                            console.warn('Validation failed for connection', cid, validation.errors);
                            continue;
                        }
                        conn.dc.send(msg.serialize());
                        sentCount++;
                    }
                    // Fallback: if exactly one open connection with no peerId yet but we have remotePeerId, assign and retry once
                    if (sentCount === 0) {
                        if (unidentifiedConnections === connections.size && connections.size === 1) {
                            const [[cid, onlyConn]] = connections.entries();
                            if (remotePeerId) {
                                console.log('Assigning peerId late to connection', cid, 'from remotePeerId');
                                onlyConn.peerId = remotePeerId;
                                const msg = LP2P.MessageFactory.createText(peerId, onlyConn.peerId, text);
                                await signMessage(msg);
                                const validation = LP2P.MessageValidator.validate(msg);
                                if (validation.valid) {
                                    onlyConn.dc.send(msg.serialize());
                                    sentCount = 1;
                                }
                            }
                        }
                    }
                    if (sentCount === 0) {
                        alert('Awaiting peer introduction (HELLO). Please wait a moment and retry.');
                        return;
                    }
                    addMessage(text + (sentCount > 1 ? ` (broadcast to ${sentCount} peers)` : ''), true);
                    messageInput.value = '';
                    return;
                }

                // Legacy single-connection fallback
                if (!dataChannel || dataChannel.readyState !== 'open') {
                    alert('Not connected');
                    return;
                }
                if (!remotePeerId) {
                    alert('Remote peer not identified yet');
                    return;
                }
                const message = LP2P.MessageFactory.createText(peerId, remotePeerId, text);
                await signMessage(message);
                const validation = LP2P.MessageValidator.validate(message);
                if (!validation.valid) {
                    console.error('Message validation failed:', validation.errors);
                    alert('Failed to send message: ' + validation.errors.join(', '));
                    return;
                }
                sendRawMessage(message);
                addMessage(text, true, message.id);
                messageInput.value = '';
            } catch (error) {
                console.error('Error sending message:', error);
                alert('Failed to send message: ' + error.message);
            }
        }

        /**
         * Send a raw protocol message
         */
        function sendRawMessage(message, targetChannel = null) {
            const wire = message.serialize();
            console.log('Sending message:', message);
            
            // Use specified channel or legacy single dataChannel
            const dc = targetChannel || dataChannel;
            if (!dc || dc.readyState !== 'open') {
                console.error('Cannot send message: channel not open');
                return;
            }
            dc.send(wire);
        }

        /**
         * Sign a message with our identity
         */
        async function signMessage(message) {
            if (!ownIdentity) {
                console.warn('Cannot sign message: no identity');
                return;
            }
            
            // Create signature payload (message without signature field)
            const payload = {
                id: message.id,
                type: message.type,
                version: message.version,
                timestamp: message.timestamp,
                sender: message.sender,
                recipient: message.recipient,
                payload: message.payload
            };
            
            // Serialize to JSON string for signing
            const payloadString = JSON.stringify(payload);
            const signature = await ownIdentity.sign(payloadString);
            message.signature = signature;
        }

        /**
         * Verify a message signature
         */
        async function verifyMessage(message) {
            if (!message.signature) {
                return false; // No signature to verify
            }
            
            // Get sender's trust record from known peers
            const trustRecord = identityManager.getPeer(message.sender);
            if (!trustRecord) {
                console.warn('Cannot verify: sender not in known peers');
                return false;
            }
            
            // Create signature payload (message without signature field)
            const payload = {
                id: message.id,
                type: message.type,
                version: message.version,
                timestamp: message.timestamp,
                sender: message.sender,
                recipient: message.recipient,
                payload: message.payload
            };
            
            // Serialize to JSON string for verification
            const payloadString = JSON.stringify(payload);
            
            // Create a PeerIdentity object from the trust record
            const peerIdentity = new LP2PIdentity.PeerIdentity({
                id: trustRecord.peerId,
                publicKey: trustRecord.publicKey,
                fingerprint: trustRecord.fingerprint,
                keyId: trustRecord.keyId,
                profile: trustRecord.profile
            });
            
            return await peerIdentity.verify(payloadString, message.signature);
        }

        /**
         * Select a peer from the roster
         */
        function selectPeer(peerId) {
            activePeerId = peerId;
            remotePeerId = peerId; // Update legacy variable for compatibility
            updatePeerRoster();
            displayPeerInfo();
        }


        /**
         * Send hello message to introduce ourselves
         */
        async function sendHello(targetChannel = null) {
            const peerInfo = ownIdentity.getPublicInfo();
            
            const message = LP2P.MessageFactory.createHello(peerId, peerInfo);
            
            // Sign the message
            await signMessage(message);
            
            sendRawMessage(message, targetChannel);
        }

        /**
         * Send goodbye message
         */
        function sendGoodbye() {
            if (!remotePeerId) return;
            
            const message = LP2P.MessageFactory.createGoodbye(peerId);
            sendRawMessage(message);
        }

        /**
         * Show PeerJS connection status
         */
        function showPeerJSStatus() {
            if (window.globalPeerJS && window.globalPeerJS.peer) {
                const onlinePeers = window.globalPeerJS.getOnlinePeers();
                alert(`‚úÖ Connected to P2P network\n\nYour ID: ${peerId}\nOnline peers: ${onlinePeers.length}\n\nYou can connect to peers by selecting them from the Contacts list.`);
            } else {
                alert('‚ùå Not connected to P2P network.\n\nPlease refresh the page to reconnect.');
            }
        }
        
        /**
         * Manually refresh presence for all known contacts
         */
        async function refreshPresence() {
            if (!window.globalPeerJS) {
                alert('Not connected to P2P network');
                return;
            }
            
            const knownPeers = identityManager.getAllPeers();
            if (knownPeers.length === 0) {
                alert('No contacts to check. Add some contacts first!');
                return;
            }
            
            addSystemMessage(`üîÑ Checking presence for ${knownPeers.length} contacts...`);
            await window.globalPeerJS.refreshPresence();
            addSystemMessage(`‚úÖ Presence check complete`);
        }

        // ====================================================================
        // Initialize
        // ====================================================================

        /**
         * Initialize the application
         */
        async function init() {
            // Check if this is first time (no identity in localStorage)
            const isFirstTime = !localStorage.getItem('lp2p.identity');
            
            if (isFirstTime) {
                // Show username modal for first-time setup
                showUsernameModal();
                return; // Wait for user to set username
            }
            
            // Load existing identity
            identityManager = new LP2PIdentity.IdentityManager();
            await identityManager.initialize();
            ownIdentity = identityManager.getOwnIdentity();
            
            // Use identity's ID as our peer ID
            peerId = ownIdentity.id;
            console.log('Our peer ID:', peerId);
            console.log('Our fingerprint:', ownIdentity.fingerprint);
            
            // Display identity in UI
            displayIdentity();
            
            // Initialize message handlers
            initMessageHandlers();

            // Initialize rooms UI from local store
            try { if (typeof initRoomsUI === 'function') await initRoomsUI(); } catch(e) { console.warn('initRoomsUI failed', e); }
            
            // Populate contacts list with known peers from localStorage
            try { updatePeerRoster(); } catch(e) { console.warn('updatePeerRoster failed', e); }
            
            console.log('Local P2P Messenger initialized with protocol v' + LP2P.PROTOCOL.VERSION);
            
            // Auto-connect to PeerJS with presence tracking
            await initPeerJSConnection();
        }
        
        /**
         * Initialize PeerJS connection with presence tracking
         */
        async function initPeerJSConnection() {
            try {
                updateStatus('connecting', 'Connecting to P2P network...');
                
                // Create global PeerJS signaling instance
                window.globalPeerJS = new LP2PSignaling.PeerJSSignaling({
                    enablePresence: true,
                    onGetKnownPeers: () => {
                        // Return list of known peer IDs from identity manager
                        if (!identityManager) return [];
                        const allPeers = identityManager.getAllPeers();
                        return allPeers.map(p => p.peerId);
                    },
                    onPresenceUpdate: (onlinePeers) => {
                        console.log('üì° Online peers:', onlinePeers.length);
                        // Update presence map for UI
                        if (typeof window !== 'undefined') {
                            if (!window.presenceMap) window.presenceMap = new Map();
                            const now = Date.now();
                            // Clear old entries
                            window.presenceMap.clear();
                            // Add current online peers
                            for (const pid of onlinePeers) {
                                window.presenceMap.set(pid, { lastSeen: now, via: 'p2p-ping' });
                            }
                            // Update UI roster
                            if (typeof updatePeerRoster === 'function') {
                                updatePeerRoster();
                            }
                        }
                    },
                    onConnectionStatusChange: (status, error) => {
                        console.log('PeerJS status:', status);
                        if (status === 'connected') {
                            updateStatus('connected', 'Connected to P2P network');
                            // Hide status bar after 2 seconds
                            setTimeout(() => {
                                const statusBar = document.querySelector('.status-bar');
                                if (statusBar) statusBar.style.display = 'none';
                            }, 2000);
                        } else if (status === 'disconnected' || status === 'error') {
                            updateStatus('error', 'Disconnected from P2P network');
                            // Show status bar
                            const statusBar = document.querySelector('.status-bar');
                            if (statusBar) statusBar.style.display = 'flex';
                        }
                    }
                });
                
                // Connect to PeerJS
                await window.globalPeerJS.connect(peerId);
                
                // Set up signaling for incoming connections
                window.globalPeerJS.onOffer = async (sdp, fromPeerId) => {
                    console.log('Global: Received offer from', fromPeerId);
                    await handleIncomingOffer(sdp, fromPeerId);
                };
                
                window.globalPeerJS.onAnswer = async (sdp, fromPeerId) => {
                    console.log('Global: Received answer from', fromPeerId);
                    await handleIncomingAnswer(sdp, fromPeerId);
                };
                
                addSystemMessage('‚úÖ Connected to P2P network');
                console.info('üîé Presence tracking: Direct P2P pings (no server required)');
                
            } catch (error) {
                console.error('Failed to connect to PeerJS:', error);
                updateStatus('error', 'Failed to connect: ' + error.message);
                // Keep status bar visible on error
                addSystemMessage('‚ö†Ô∏è Failed to connect to P2P network. You can still create/join rooms.');
            }
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
