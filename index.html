<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local P2P Messenger</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header .subtitle {
            font-size: 14px;
            opacity: 0.9;
        }

        .status-bar {
            padding: 15px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #28a745;
            animation: none;
        }

        .status-indicator.connecting {
            background: #ffc107;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: #e0e0e0;
        }

        .panel {
            background: white;
            padding: 20px;
        }

        .panel h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #333;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #218838;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            transition: border-color 0.2s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .signal-area {
            min-height: 150px;
            margin-bottom: 10px;
        }

        .chat-section {
            grid-column: 1 / -1;
            border-top: 1px solid #e0e0e0;
        }

        .messages {
            height: 300px;
            overflow-y: auto;
            padding: 15px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 15px;
        }

        .message {
            margin-bottom: 12px;
            padding: 10px 12px;
            border-radius: 6px;
            max-width: 70%;
            word-wrap: break-word;
        }

        .message.sent {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }

        .message.received {
            background: white;
            border: 1px solid #e0e0e0;
        }

        .message-time {
            font-size: 11px;
            opacity: 0.7;
            margin-top: 4px;
        }

        .message-input-group {
            display: flex;
            gap: 10px;
        }

        .message-input-group input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
        }

        .message-input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .message-input-group button {
            flex: 0 0 100px;
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
            line-height: 1.4;
        }

        .instructions {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 13px;
            color: #856404;
        }

        .instructions strong {
            display: block;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîó Local P2P Messenger</h1>
            <div class="subtitle">WebRTC-based peer-to-peer communication</div>
        </div>

        <div class="status-bar">
            <div class="status-indicator" id="statusIndicator"></div>
            <div class="status-text" id="statusText">Disconnected</div>
        </div>

        <!-- Identity Info -->
        <div id="identityInfo" style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 12px; margin-bottom: 15px; font-size: 12px; font-family: monospace;">
            Initializing identity...
        </div>

        <!-- Username Setup Modal (shown on first load) -->
        <div id="usernameModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div style="background: white; padding: 30px; border-radius: 12px; max-width: 400px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                <h2 style="margin-top: 0; color: #667eea;">üëã Welcome to LP2P!</h2>
                <p style="color: #666; margin-bottom: 20px;">Choose a display name for your identity. This will be shown to peers you connect with.</p>
                <input type="text" id="usernameInput" placeholder="Enter your name..." style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; margin-bottom: 20px; box-sizing: border-box;" />
                <button onclick="setUsername()" style="width: 100%; padding: 12px; background: #667eea; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">Continue</button>
            </div>
        </div>

        <div class="main-content">
            <!-- Peer A (Offerer) Panel -->
            <div class="panel">
                <h2>üë§ Peer A (Offerer)</h2>
                
                <div class="instructions">
                    <strong>Step 1:</strong> Click "Create Offer" to start
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="createOfferBtn" onclick="createOffer()">Create Offer</button>
                </div>

                <textarea id="offerText" class="signal-area" placeholder="Your offer will appear here..." readonly></textarea>
                
                <div class="help-text">üìã Copy this offer and paste it in Peer B on the other browser</div>

                <h2 style="margin-top: 20px;">üì• Paste Answer Here</h2>
                
                <textarea id="answerInput" class="signal-area" placeholder="Paste the answer from Peer B here..."></textarea>
                
                <button class="btn-success" id="setAnswerBtn" onclick="setAnswer()" disabled>Apply Answer</button>
            </div>

            <!-- Peer B (Answerer) Panel -->
            <div class="panel">
                <h2>üë§ Peer B (Answerer)</h2>
                
                <div class="instructions">
                    <strong>Step 2:</strong> Paste the offer from Peer A
                </div>

                <textarea id="offerInput" class="signal-area" placeholder="Paste the offer from Peer A here..."></textarea>
                
                <div class="button-group">
                    <button class="btn-primary" id="createAnswerBtn" onclick="createAnswer()">Create Answer</button>
                </div>

                <textarea id="answerText" class="signal-area" placeholder="Your answer will appear here..." readonly></textarea>
                
                <div class="help-text">üìã Copy this answer and paste it in Peer A on the other browser</div>
            </div>

            <!-- Chat Section -->
            <div class="chat-section panel">
                <h2>üí¨ Messages</h2>
                
                <div class="messages" id="messages">
                    <div style="text-align: center; color: #999; padding: 40px 20px;">
                        No connection yet. Complete the signaling process to start chatting.
                    </div>
                </div>

                <div class="message-input-group">
                    <input type="text" id="messageInput" placeholder="Type your message..." disabled>
                    <button class="btn-primary" id="sendBtn" onclick="sendMessage()" disabled>Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Protocol Layer -->
    <script src="protocol.js"></script>
    
    <!-- Identity Layer -->
    <script src="identity.js"></script>

    <script>
        // WebRTC Configuration
        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Global state
        let peerConnection = null;
        let dataChannel = null;
        let isOfferer = false;
        let peerId = null;  // Our peer ID
        let remotePeerId = null;  // Remote peer ID
        let messageHandler = null;  // Message handler instance
        let identityManager = null;  // Identity manager instance
        let ownIdentity = null;  // Our identity

        // UI Elements
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const offerText = document.getElementById('offerText');
        const answerInput = document.getElementById('answerInput');
        const offerInput = document.getElementById('offerInput');
        const answerText = document.getElementById('answerText');
        const messagesDiv = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const setAnswerBtn = document.getElementById('setAnswerBtn');

        /**
         * Update connection status UI
         */
        function updateStatus(status, message) {
            statusIndicator.className = 'status-indicator ' + status;
            statusText.textContent = message;
        }

        /**
         * Initialize RTCPeerConnection
         */
        function initPeerConnection() {
            peerConnection = new RTCPeerConnection(config);

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate === null) {
                    // ICE gathering complete
                    console.log('ICE gathering complete');
                }
            };

            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                
                switch (peerConnection.connectionState) {
                    case 'connecting':
                        updateStatus('connecting', 'Connecting...');
                        break;
                    case 'connected':
                        updateStatus('connected', 'Connected');
                        break;
                    case 'disconnected':
                        updateStatus('', 'Disconnected');
                        disableChat();
                        break;
                    case 'failed':
                        updateStatus('', 'Connection failed');
                        disableChat();
                        break;
                }
            };

            // Handle incoming data channel (for answerer)
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel();
            };
        }

        /**
         * Setup data channel event handlers
         */
        function setupDataChannel() {
            dataChannel.onopen = () => {
                console.log('Data channel opened');
                
                // Send hello message to introduce ourselves
                sendHello();
                
                enableChat();
            };

            dataChannel.onclose = () => {
                console.log('Data channel closed');
                
                // Send goodbye if still connected to peer
                if (remotePeerId) {
                    sendGoodbye();
                }
                
                disableChat();
            };

            dataChannel.onmessage = async (event) => {
                console.log('Received raw data:', event.data);
                
                try {
                    // Deserialize the message
                    const message = LP2P.Message.deserialize(event.data);
                    console.log('Received message:', message);
                    
                    // Verify signature if present
                    if (message.signature) {
                        const isValid = await verifyMessage(message);
                        console.log('Message signature valid:', isValid);
                        message.signatureValid = isValid;
                    }
                    
                    // Handle the message
                    await messageHandler.handle(message);
                } catch (error) {
                    console.error('Error handling message:', error);
                    
                    // Send error response if possible
                    if (remotePeerId) {
                        const errorMsg = LP2P.MessageFactory.createError(
                            peerId,
                            remotePeerId,
                            LP2P.ERROR_CODES.INVALID_FORMAT,
                            error.message
                        );
                        sendRawMessage(errorMsg);
                    }
                }
            };

            dataChannel.onerror = (error) => {
                console.error('Data channel error:', error);
            };
        }

        /**
         * Create an offer (Peer A)
         */
        async function createOffer() {
            try {
                isOfferer = true;
                initPeerConnection();

                // Create data channel
                dataChannel = peerConnection.createDataChannel('messages');
                setupDataChannel();

                // Create and set local description
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Wait for ICE gathering to complete
                await waitForICE();

                // Display offer
                offerText.value = JSON.stringify(peerConnection.localDescription);
                
                // Enable answer input
                setAnswerBtn.disabled = false;
                
                updateStatus('connecting', 'Offer created - waiting for answer');
                
                console.log('Offer created:', peerConnection.localDescription);
            } catch (error) {
                console.error('Error creating offer:', error);
                alert('Failed to create offer: ' + error.message);
            }
        }

        /**
         * Create an answer (Peer B)
         */
        async function createAnswer() {
            try {
                const offerText = offerInput.value.trim();
                
                if (!offerText) {
                    alert('Please paste an offer first');
                    return;
                }

                isOfferer = false;
                initPeerConnection();

                // Parse and set remote description
                const offer = JSON.parse(offerText);
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                // Create and set local description
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                // Wait for ICE gathering to complete
                await waitForICE();

                // Display answer
                answerText.value = JSON.stringify(peerConnection.localDescription);
                
                updateStatus('connecting', 'Answer created - waiting for connection');
                
                console.log('Answer created:', peerConnection.localDescription);
            } catch (error) {
                console.error('Error creating answer:', error);
                alert('Failed to create answer: ' + error.message);
            }
        }

        /**
         * Set answer (Peer A)
         */
        async function setAnswer() {
            try {
                const answerStr = answerInput.value.trim();
                
                if (!answerStr) {
                    alert('Please paste an answer first');
                    return;
                }

                const answer = JSON.parse(answerStr);
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                
                console.log('Answer applied');
                setAnswerBtn.disabled = true;
            } catch (error) {
                console.error('Error setting answer:', error);
                alert('Failed to apply answer: ' + error.message);
            }
        }

        /**
         * Wait for ICE gathering to complete
         */
        function waitForICE() {
            return new Promise((resolve) => {
                if (peerConnection.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    peerConnection.addEventListener('icegatheringstatechange', () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            resolve();
                        }
                    });
                }
            });
        }

        /**
         * Send a message
         */
        async function sendMessage() {
            const text = messageInput.value.trim();
            
            if (!text) return;
            
            if (!dataChannel || dataChannel.readyState !== 'open') {
                alert('Not connected');
                return;
            }

            if (!remotePeerId) {
                alert('Remote peer not identified yet');
                return;
            }

            try {
                // Create structured message
                const message = LP2P.MessageFactory.createText(peerId, remotePeerId, text);
                
                // Sign the message
                await signMessage(message);
                
                // Validate before sending
                const validation = LP2P.MessageValidator.validate(message);
                if (!validation.valid) {
                    console.error('Message validation failed:', validation.errors);
                    alert('Failed to send message: ' + validation.errors.join(', '));
                    return;
                }
                
                // Send the message
                sendRawMessage(message);
                
                // Display in our UI
                addMessage(text, true, message.id);
                
                messageInput.value = '';
            } catch (error) {
                console.error('Error sending message:', error);
                alert('Failed to send message: ' + error.message);
            }
        }

        /**
         * Send a raw protocol message
         */
        function sendRawMessage(message) {
            const wire = message.serialize();
            console.log('Sending message:', message);
            dataChannel.send(wire);
        }

        /**
         * Sign a message with our identity
         */
        async function signMessage(message) {
            if (!ownIdentity) {
                console.warn('Cannot sign message: no identity');
                return;
            }
            
            // Create signature payload (message without signature field)
            const payload = {
                id: message.id,
                type: message.type,
                version: message.version,
                timestamp: message.timestamp,
                sender: message.sender,
                recipient: message.recipient,
                payload: message.payload
            };
            
            // Serialize to JSON string for signing
            const payloadString = JSON.stringify(payload);
            const signature = await ownIdentity.sign(payloadString);
            message.signature = signature;
        }

        /**
         * Verify a message signature
         */
        async function verifyMessage(message) {
            if (!message.signature) {
                return false; // No signature to verify
            }
            
            // Get sender's trust record from known peers
            const trustRecord = identityManager.getPeer(message.sender);
            if (!trustRecord) {
                console.warn('Cannot verify: sender not in known peers');
                return false;
            }
            
            // Create signature payload (message without signature field)
            const payload = {
                id: message.id,
                type: message.type,
                version: message.version,
                timestamp: message.timestamp,
                sender: message.sender,
                recipient: message.recipient,
                payload: message.payload
            };
            
            // Serialize to JSON string for verification
            const payloadString = JSON.stringify(payload);
            
            // Create a PeerIdentity object from the trust record
            const peerIdentity = new LP2PIdentity.PeerIdentity({
                id: trustRecord.peerId,
                publicKey: trustRecord.publicKey,
                fingerprint: trustRecord.fingerprint,
                keyId: trustRecord.keyId,
                profile: trustRecord.profile
            });
            
            return await peerIdentity.verify(payloadString, message.signature);
        }

        /**
         * Display our identity information
         */
        function displayIdentity() {
            const identityInfo = document.getElementById('identityInfo');
            if (!identityInfo) return;
            
            const fingerprint = ownIdentity.fingerprint;
            const keyId = ownIdentity.keyId;
            const displayName = ownIdentity.profile.name || 'Anonymous';
            
            identityInfo.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: start;">
                    <div>
                        <strong>Your Identity</strong><br>
                        Name: <strong>${displayName}</strong> 
                        <button onclick="changeName()" style="font-size: 10px; padding: 2px 6px; margin-left: 5px; cursor: pointer; background: #667eea; color: white; border: none; border-radius: 3px;">‚úèÔ∏è Edit</button><br>
                        Key ID: <code>${keyId}</code><br>
                        Fingerprint: <code style="font-size: 10px;">${fingerprint}</code>
                    </div>
                </div>
            `;
        }

        /**
         * Change display name
         */
        async function changeName() {
            const currentName = ownIdentity.profile.name;
            const newName = prompt('Enter new display name:', currentName);
            
            if (newName && newName.trim() && newName.trim() !== currentName) {
                await identityManager.updateProfile({ name: newName.trim() });
                ownIdentity = identityManager.getOwnIdentity();
                displayIdentity();
                console.log('Name updated to:', newName.trim());
            }
        }

        /**
         * Send hello message to introduce ourselves
         */
        async function sendHello() {
            const peerInfo = ownIdentity.getPublicInfo();
            
            const message = LP2P.MessageFactory.createHello(peerId, peerInfo);
            
            // Sign the message
            await signMessage(message);
            
            sendRawMessage(message);
        }

        /**
         * Send goodbye message
         */
        function sendGoodbye() {
            if (!remotePeerId) return;
            
            const message = LP2P.MessageFactory.createGoodbye(peerId);
            sendRawMessage(message);
        }

        /**
         * Add a message to the chat
         */
        function addMessage(text, isSent, messageId = null) {
            // Clear placeholder if exists
            if (messagesDiv.children.length === 1 && messagesDiv.children[0].style.textAlign === 'center') {
                messagesDiv.innerHTML = '';
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + (isSent ? 'sent' : 'received');
            if (messageId) {
                messageDiv.dataset.messageId = messageId;
            }
            
            const textDiv = document.createElement('div');
            textDiv.textContent = text;
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            timeDiv.textContent = new Date().toLocaleTimeString();
            
            messageDiv.appendChild(textDiv);
            messageDiv.appendChild(timeDiv);
            messagesDiv.appendChild(messageDiv);
            
            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        /**
         * Add a system message to the chat
         */
        function addSystemMessage(text) {
            // Clear placeholder if exists
            if (messagesDiv.children.length === 1 && messagesDiv.children[0].style.textAlign === 'center') {
                messagesDiv.innerHTML = '';
            }

            const messageDiv = document.createElement('div');
            messageDiv.style.textAlign = 'center';
            messageDiv.style.color = '#999';
            messageDiv.style.fontSize = '13px';
            messageDiv.style.margin = '10px 0';
            messageDiv.textContent = text;
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        /**
         * Enable chat UI
         */
        function enableChat() {
            messageInput.disabled = false;
            sendBtn.disabled = false;
            messageInput.focus();
        }

        /**
         * Disable chat UI
         */
        function disableChat() {
            messageInput.disabled = true;
            sendBtn.disabled = true;
        }

        /**
         * Handle Enter key in message input
         */
        messageInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        // ====================================================================
        // Message Protocol Handlers
        // ====================================================================

        /**
         * Initialize message handlers
         */
        function initMessageHandlers() {
            messageHandler = new LP2P.MessageHandler();
            
            // Handle text messages
            messageHandler.register(LP2P.MESSAGE_TYPES.TEXT, (message) => {
                console.log('Handling text message:', message);
                
                // Add verification indicator if message was signed
                let displayText = message.payload.text;
                if (message.signature !== undefined) {
                    const icon = message.signatureValid ? '‚úì' : '‚ö†';
                    displayText = `${icon} ${displayText}`;
                }
                
                addMessage(displayText, false, message.id);
            });
            
            // Handle system messages
            messageHandler.registerAction(LP2P.MESSAGE_TYPES.SYSTEM, LP2P.SYSTEM_ACTIONS.HELLO, async (message) => {
                console.log('Peer introduced:', message.payload.peerInfo);
                remotePeerId = message.from;
                
                const peerInfo = message.payload.peerInfo;
                const peerName = peerInfo.profile?.name || peerInfo.name || message.from;
                
                // Add peer to known peers if we have their public key
                if (peerInfo.publicKey) {
                    const trustRecord = await identityManager.addPeer(peerInfo);
                    
                    // Set initial trust level to unknown
                    await identityManager.setTrust(peerInfo.id, 'unknown');
                    
                    console.log('Added peer with fingerprint:', trustRecord.fingerprint);
                    
                    // Show signature verification status
                    if (message.signatureValid) {
                        addSystemMessage(`‚úì ${peerName} connected (verified)`);
                    } else {
                        addSystemMessage(`‚ö† ${peerName} connected (unverified)`);
                    }
                } else {
                    addSystemMessage(`${peerName} connected`);
                }
                
                updateStatus('connected', `Connected to ${peerName}`);
            });
            
            messageHandler.registerAction(LP2P.MESSAGE_TYPES.SYSTEM, LP2P.SYSTEM_ACTIONS.GOODBYE, (message) => {
                console.log('Peer disconnecting:', message.from);
                
                const reason = message.payload.reason || 'disconnected';
                addSystemMessage(`Peer ${reason}`);
            });
            
            messageHandler.registerAction(LP2P.MESSAGE_TYPES.SYSTEM, LP2P.SYSTEM_ACTIONS.PING, (message) => {
                console.log('Received ping from:', message.from);
                
                // Send pong response
                const pong = LP2P.MessageFactory.createPong(peerId, message.from, message.id);
                sendRawMessage(pong);
            });
            
            messageHandler.registerAction(LP2P.MESSAGE_TYPES.SYSTEM, LP2P.SYSTEM_ACTIONS.ERROR, (message) => {
                console.error('Received error from peer:', message.payload);
                addSystemMessage(`Error: ${message.payload.message}`);
            });
            
            // Handle control messages
            messageHandler.registerAction(LP2P.MESSAGE_TYPES.CONTROL, LP2P.CONTROL_ACTIONS.TYPING, (message) => {
                console.log('Peer typing:', message.payload.active);
                // Could show typing indicator in UI
            });
        }

        // ====================================================================
        // Initialize
        // ====================================================================

        /**
         * Initialize the application
         */
        async function init() {
            // Check if this is first time (no identity in localStorage)
            const isFirstTime = !localStorage.getItem('lp2p_identity');
            
            if (isFirstTime) {
                // Show username modal
                showUsernameModal();
                return; // Wait for user to set username
            }
            
            // Initialize identity manager
            identityManager = new LP2PIdentity.IdentityManager();
            await identityManager.initialize();
            ownIdentity = identityManager.getOwnIdentity();
            
            // Use identity's ID as our peer ID
            peerId = ownIdentity.id;
            console.log('Our peer ID:', peerId);
            console.log('Our fingerprint:', ownIdentity.fingerprint);
            
            // Display identity in UI
            displayIdentity();
            
            // Initialize message handlers
            initMessageHandlers();
            
            console.log('Local P2P Messenger initialized with protocol v' + LP2P.PROTOCOL.VERSION);
            updateStatus('', 'Disconnected');
        }

        /**
         * Show username setup modal
         */
        function showUsernameModal() {
            const modal = document.getElementById('usernameModal');
            modal.style.display = 'flex';
            
            const input = document.getElementById('usernameInput');
            input.focus();
            
            // Allow Enter key to submit
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    setUsername();
                }
            });
        }

        /**
         * Set username and create identity
         */
        async function setUsername() {
            const input = document.getElementById('usernameInput');
            const username = input.value.trim();
            
            if (!username) {
                alert('Please enter a name');
                return;
            }
            
            // Hide modal
            const modal = document.getElementById('usernameModal');
            modal.style.display = 'none';
            
            // Create identity with chosen name
            identityManager = new LP2PIdentity.IdentityManager();
            await identityManager.initialize({ name: username });
            ownIdentity = identityManager.getOwnIdentity();
            
            // Use identity's ID as our peer ID
            peerId = ownIdentity.id;
            console.log('Our peer ID:', peerId);
            console.log('Our fingerprint:', ownIdentity.fingerprint);
            
            // Display identity in UI
            displayIdentity();
            
            // Initialize message handlers
            initMessageHandlers();
            
            console.log('Local P2P Messenger initialized with protocol v' + LP2P.PROTOCOL.VERSION);
            updateStatus('', 'Disconnected');
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
